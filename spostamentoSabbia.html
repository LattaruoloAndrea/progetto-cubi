<html>
	<head>
		<title>Load OBJ File</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OrbitControls.js"></script>
		</head>
	<body>

		<script>

			var scene, renderer, camera, stats,controls,axesHelper;
			var granelli=[],iesimoGranello=0,h,l,d,ClessidraSx,arrayPosGranelli = [];
			var num ,t,start,end,dimSabbia;
			var pivotAggiustaMovimento;
			var tempo = [];
			var posIesimaX =[],posIesimaY = [],posIesimaZ = [], p=[], omg =[];
			function Start()
      {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0xf0f0f0 );
				document.body.appendChild( renderer.domElement );

				//axies
				axesHelper = new THREE.AxisHelper( 5 );

				//per render
				pivotAggiustaMovimento = new THREE.Object3D();

				//controllo camera
				controls = new THREE.OrbitControls(camera);
				controls.enableDamping = true ;
				controls.dampingFactor = 0.25;


				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

				camera.position.z = 20;
				/*
				var hh = 2;
				var ll = 2;
				var dd = 2;
				granelli = sabbia(ll,hh,dd,0xff0000);
				num = hh*ll*dd;
				initializePosition(granelli);
				*/
				//clessidra
				ClessidraSx = new THREE.Object3D();
				var moltiplicatoreDim = 2;
				var altezzaClessidra = moltiplicatoreDim * 20;
				dimSabbia = 0.5;
				h=moltiplicatoreDim*15;
				costruzioneClessidra(ClessidraSx, altezzaClessidra, moltiplicatoreDim);
				scene.add(ClessidraSx,axesHelper,pivotAggiustaMovimento);

			}

			function sabbia(larghezza,altezza,profondita,dimBase,colore,mul,image){
				console.log(larghezza, profondita);
				var geometryGranello = new THREE.BoxGeometry(dimSabbia,dimSabbia,dimSabbia);
				var materialeGranello;
				var numGranello = 0;
				var grane = [];
				var xD=-dimBase*mul/2+5*dimSabbia/2,yD=6-1+dimSabbia/2,zD=-dimBase*mul/2+5*dimSabbia/2;//-dimSabbia
				for(var i=0;i<altezza;i++){
					for(var j=0;j<larghezza;j++){
						for(var k=0;k<profondita;k++){
							if(image==undefined){
								materialeGranello = new THREE.MeshBasicMaterial( { color: colore } );
							}
							else{
								var texture = new THREE.TextureLoader().load( image );
								materialeGranello = new THREE.MeshBasicMaterial( {map:texture});
							}
							var granello =new THREE.Mesh(geometryGranello,materialeGranello);
							granello.position.set(xD,yD,zD);
							arrayPosGranelli.push(new THREE.Vector3(xD,yD,zD));
							grane.push(granello);
							numGranello += 1;
							xD += dimSabbia;
						}
						xD=-dimBase*mul/2+5*dimSabbia/2;
						zD +=dimSabbia;
					}
					zD=-dimBase*mul/2+5*dimSabbia/2;
					yD+=dimSabbia;
				}
				return grane;
			}

			function initializePosition(listaGranelli){
				var posStart = listaGranelli.length-1;
				for(var i=0;i<listaGranelli.length;i++){
					 //posIesimaX[i]=listaGranelli[posStart].position.x;
					 //posIesimaY[i]=listaGranelli[posStart].position.y;
					 //posIesimaZ[i]=listaGranelli[posStart].position.z;
					//posIesimaX[i]= 0;
					posIesimaY[i]= 0;
					//posIesimaZ[i]= 0;
					p[i] =0;
					//omg[i] =true;
					tempo[i] = 0;
				}
				console.log(tempo.length);
			}


			/*
			function sabbiaUpdate(velocita,listaGranelli,h,l,d){
				//h = altezza l= lunghezza d = profondita
				for(var i=0;i<iesimoGranello;i++){
					if(iesimoGranello>=l){//inizio l'inversione

						}
						else{
							posIesimaX[i] += velocita;
							posIesimaY[i] += velocita/10;
							posIesimaZ[i] += velocita;
							if(p<l){p += 0.5;}
							else{p = 0;}
							granelli[iesimoGranello].position.set(Math.cos(posIesimaX)*(l-p),0,-Math.sin(posIesimaZ)*(d-p));//Math.sin(posIesimaY)*h
						}
						iesimoGranello += 1;
					}
				}
				*/

				var gap = 0.9,count =0;
				var angolo = 2.0;
				var posX=0,posY=0,posZ=0;
				var inverso = false;

				function Render()
	      {
				     requestAnimationFrame(Render);
						 controls.update();
						 //
						 if(inverso)//verso inverso
						 {
							 if(count<1){
 							for(var i=start;i>=end;i--){
 								if(posIesimaY[i]<=h/2){
 										p[i] -= (l*gap)/(h*2*Math.PI);
 								}
 								else{
 										p[i]+=(l*gap)/(h*2*Math.PI);
 								}
								if(i == start) {
 									tempo[i] += angolo/(2.0*Math.PI);
 								}else {
 									tempo[i] = Math.max(0.0, tempo[i+1]-angolo/(2.0*Math.PI));
 								}

 								//pivot usato per centrare  la spirale inversa
 								pivotAggiustaMovimento.add(granelli[i]);
 								pivotAggiustaMovimento.position.set(0,6-(3*dimSabbia/2),0);

 								//spirale granelli inversa
 								granelli[i].position.set(Math.cos(tempo[i])*(l/2-p[i]),posIesimaY[i],Math.sin(tempo[i])*(d/2-p[i]));//-(i*60)
 								posIesimaY[i] -= gap/(2.0*Math.PI);

 								//quando arrivo all'altezzaMassima devo ordinare i granelli nella griglia
 								if(posIesimaY[i]<=dimSabbia){
 									start -= 1;//il primo granello non serve piu contarlo
 									var x = arrayPosGranelli[i].x;
 									var y = arrayPosGranelli[i].y;
 									var z = arrayPosGranelli[i].z;
 									granelli[i].position.set(x,y-5,z);//dimSabbia
 									if(start==-1){//abilito drirro
 										inverso=false;
 										start= t-1;
 										end = t-1;
 									}
 								}
 								count +=1;
 						 		}
 							}else{
 								if(end>0){
 								end -=1;}
 								count =0;
 							}
						 }
						 else//verso dritto
						 {
						  if(count<1){
							for(var i=start;i>=end;i--){
								if(posIesimaY[i]<=h/2){
										p[i] += (l*gap)/(h*2*Math.PI);
								}
								else{
										p[i]-=(l*gap)/(h*2*Math.PI);
										}
								if(i == start) {
									tempo[i] += angolo/(2.0*Math.PI);
								}else {
									tempo[i] = Math.max(0.0, tempo[i+1]-angolo/(2.0*Math.PI));
								}

								//pivot usato per centrare  la spirale
								pivotAggiustaMovimento.add(granelli[i]);
								pivotAggiustaMovimento.position.set(0,6-(3*dimSabbia/2),0);

								//spirale granelli
								granelli[i].position.set(Math.cos(tempo[i])*(l/2-p[i]),posIesimaY[i],Math.sin(tempo[i])*(d/2-p[i]));//-(i*60)
								posIesimaY[i] += gap/(2.0*Math.PI);

								//quando arrivo all'altezzaMassima devo orginare i granelli
								if(posIesimaY[i]>=h-dimSabbia){
									start -= 1;//il primo granello non serve piu contarlo
									var x = arrayPosGranelli[i].x;
									var y = arrayPosGranelli[i].y;
									var z = arrayPosGranelli[i].z;
									granelli[i].position.set(x,h-(y-5),z);//dimSabbia
									if(start==-1){//abilito l'inverso
										inverso=true;
										start= t-1;
										end = t-1;
									}
								}
								count +=1;
						 		}
							}else{
								if(end>0){
								end -=1;}
								count =0;
							}
						}
						 stats.update();
					   renderer.render(scene, camera);
				}

					function costruzioneClessidra(pivotClessidra, altezzaCl, mul){
						//crea una clessidra
						var base = creaBaseClessidra(mul);
						var tetto = creaBaseClessidra(mul);
						tetto.rotation.set(180*Math.PI/180,0,0);
						tetto.position.set(0,altezzaCl,0);
						var vetro = creaVetroClessidra(mul);
						var hh = 6;
						var ll = mul*4/dimSabbia;
						var dd = mul*4/dimSabbia;
						granelli = sabbia(ll,hh,dd,5,0xff0000,mul);
						t = granelli.length;
						num = hh*ll*dd;
						start = num -1;
						end = t -1;
						if(end==start){console.log("TRUEE");}
						initializePosition(granelli);
						var pivotGranelli = new THREE.Object3D();
						for(var i=0;i<granelli.length;i++){
							pivotGranelli.add(granelli[i]);
						}
						pivotClessidra.add(vetro, base, tetto,pivotGranelli);
					}

					function creaBaseClessidra(m){
						pivot = new THREE.Object3D();
						var height = m*1;
						var basamento = m*3;
						l = basamento;
						d = basamento;
						var colorBase = 0xffd700;
						var livBase1 = creaQuadrilatero(basamento,height,basamento,colorBase, "textures/OroClessidra.jpg");
						var livBase2 = creaQuadrilatero(basamento + m*1,height, basamento + m*1,colorBase, "textures/OroClessidra.jpg");
						var livBase3 = creaQuadrilatero(basamento + m*2,height,basamento + m*2,colorBase, "textures/OroClessidra.jpg");
						livBase2.position.set(0,height,0);
						livBase3.position.set(0,2*height,0);
						pivot.add(livBase1,livBase2,livBase3);
						return pivot;
					}

					function creaVetroClessidra(m){

						// Unione pezzi clessidra
						pivotVetroClessidra = new THREE.Object3D();
						var dimensioneLato = 5;
						var posizioneVetro = m*5;
						// parte sotto
						metaClessidra1 = metaVetroClessidra(dimensioneLato, m);
						// parte sopra
						metaClessidra2 = metaVetroClessidra(dimensioneLato, m);
						// Regolazione parti sopra-sotto
						metaClessidra1.position.set(0,posizioneVetro,0);
						metaClessidra2.position.set(0,3*posizioneVetro,0);
						metaClessidra2.rotation.set(180*Math.PI/180,0,0);
						// Parte centrale
						centroClessidra = creaQuadrilateroTrasparente(m*1,m*1,m*1,0x000000);
						centroClessidra.position.set(0,2*posizioneVetro,0);
						pivotVetroClessidra.add(metaClessidra1, metaClessidra2, centroClessidra);
						return pivotVetroClessidra;
					}

					function metaVetroClessidra(l, m){
						pivot = new THREE.Object3D();
						var altezzaVetri = m*1;
						var colorBase = 0x000000;
						var metaVetro = creaQuadrilateroTrasparente(m*l,m*l,m*l,colorBase);
						var metaVetro1 = creaQuadrilateroTrasparente(m*(l-1), altezzaVetri, m*(l-1),colorBase);
						var metaVetro2 = creaQuadrilateroTrasparente(m*(l-2), altezzaVetri, m*(l-2),colorBase);
						metaVetro1.position.set(0,m*2 + altezzaVetri,0);
						metaVetro2.position.set(0,m*2 + 2*altezzaVetri,0);
						pivot.add(metaVetro, metaVetro1, metaVetro2);
						return pivot;
					}

					function creaQuadrilatero(larghezza, altezza, profondita, colore, image){
						// Costruzione plane generico
						var geometryPlane = new THREE.BoxGeometry(larghezza, altezza, profondita);
						//
						if(image == undefined){
						var planeMaterial = new THREE.MeshBasicMaterial( { color: colore } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
					} else {
						var texture = new THREE.TextureLoader().load( image );
						var planeMaterial = new THREE.MeshBasicMaterial( { map: texture } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
					}
						return plane;
					}

					function creaQuadrilateroTrasparente(larghezza, altezza, profondita, colore){
						// Costruzione plane generico
						var geometryPlane = new THREE.BoxGeometry(larghezza, altezza, profondita);
						var planeMaterial = new THREE.MeshBasicMaterial( { color: colore, transparent: true, opacity:0.05 } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
						return plane;
					}

			Start();
			Render();
		</script>
	</body>
</html>

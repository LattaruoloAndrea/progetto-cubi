<html>
	<head>
		<title>Load OBJ File</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OrbitControls.js"></script>
		</head>
	<body>

		<script>

			var scene, renderer, camera, stats,controls,axesHelper;
			var granelli1=[],granelli2=[],h,l,d,ClessidraSx,ClessidraDx,arrayPosGranelli1 = [],arrayPosGranelli2=[];
			var num ,t,start,end,dimSabbia;
			var pivotAggiustaMovimento1,pivotAggiustaMovimento2;
			var tempo1 = [],tempo2 = [];
			var posIesimaY1 = [],p1=[],posIesimaY2 = [],p2=[];
			var gap = 0.9,count =0;
			var angolo = 2.0;
			var inverso = false;


			function Start()
      {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0xf0f0f0 );
				document.body.appendChild( renderer.domElement );

				//axies
				axesHelper = new THREE.AxisHelper( 5 );

				//per render
				pivotAggiustaMovimento1 = new THREE.Object3D();
				pivotAggiustaMovimento2 = new THREE.Object3D();

				//controllo camera
				controls = new THREE.OrbitControls(camera);
				controls.enableDamping = true ;
				controls.dampingFactor = 0.25;


				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

				camera.position.z = 20;

				//clessidra
				ClessidraSx = new THREE.Object3D();
				var moltiplicatoreDim = 2;
				var altezzaClessidra = moltiplicatoreDim * 20;
				dimSabbia = 0.5;
				h=moltiplicatoreDim*15;
				costruzioneClessidra(ClessidraSx, altezzaClessidra, moltiplicatoreDim,0);
				ClessidraSx.add(pivotAggiustaMovimento1);
				//ClessidraSx.position.set(5,5,5);
				scene.add(ClessidraSx,axesHelper,pivotAggiustaMovimento2);

			}

			function sabbia(larghezza,altezza,profondita,dimBase,colore,mul,cl,image){
				console.log(larghezza, profondita);
				var geometryGranello = new THREE.BoxGeometry(dimSabbia,dimSabbia,dimSabbia);
				var materialeGranello;
				var numGranello = 0;
				var grane = [];
				var xD=-dimBase*mul/2+5*dimSabbia/2,yD=6-1+dimSabbia/2,zD=-dimBase*mul/2+5*dimSabbia/2;//-dimSabbia
				for(var i=0;i<altezza;i++){
					for(var j=0;j<larghezza;j++){
						for(var k=0;k<profondita;k++){
							if(image==undefined){
								materialeGranello = new THREE.MeshBasicMaterial( { color: colore } );
							}
							else{
								var texture = new THREE.TextureLoader().load( image );
								materialeGranello = new THREE.MeshBasicMaterial( {map:texture});
							}
							var granello =new THREE.Mesh(geometryGranello,materialeGranello);
							granello.position.set(xD,yD,zD);
							if(cl==0){
								arrayPosGranelli1.push(new THREE.Vector3(xD,yD,zD));
							}else{
								arrayPosGranelli2.push(new THREE.Vector3(xD,yD,zD));
							}
							grane.push(granello);
							numGranello += 1;
							xD += dimSabbia;
						}
						xD=-dimBase*mul/2+5*dimSabbia/2;
						zD +=dimSabbia;
					}
					zD=-dimBase*mul/2+5*dimSabbia/2;
					yD+=dimSabbia;
				}
				return grane;
			}

			function initializePosition(listaGranelli,numClessidra){
				if(numClessidra==0){
					for(var i=0;i<listaGranelli.length;i++){
						posIesimaY1[i]= 0;
						p1[i] =0;
						tempo1[i] = 0;
					}
				}else {
					for(var i=0;i<listaGranelli.length;i++){
						posIesimaY2[i]= 0;
						p2[i] =0;
						tempo2[i] = 0;
					}
				}
			}

			function costruzioneClessidra(pivotClessidra, altezzaCl, mul,graneNum){
				//crea una clessidra
				var base = creaBaseClessidra(mul);
				var tetto = creaBaseClessidra(mul);
				tetto.rotation.set(180*Math.PI/180,0,0);
				tetto.position.set(0,altezzaCl,0);
				var vetro = creaVetroClessidra(mul);
				var hh = 6;
				var ll = mul*4/dimSabbia;
				var dd = mul*4/dimSabbia;
				if(graneNum==0){
				granelli1 = sabbia(ll,hh,dd,5,0xff0000,mul,graneNum);
				t = granelli1.length;
				num = hh*ll*dd;
				start = num -1;
				end = t -1;
				initializePosition(granelli1,graneNum);
				var pivotGranelli = new THREE.Object3D();
				for(var i=0;i<granelli1.length;i++){
					pivotGranelli.add(granelli1[i]);
				}
				pivotClessidra.add(vetro, base, tetto,pivotGranelli);
				}
				else{
					granelli2 = sabbia(ll,hh,dd,5,0xff0000,mul,graneNum);
					t = granelli2.length;
					num = hh*ll*dd;
					start = num -1;
					end = t -1;
					initializePosition(granelli2,graneNum);
					var pivotGranelli = new THREE.Object3D();
					for(var i=0;i<granelli2.length;i++){
						pivotGranelli.add(granelli1[i]);
					}
					pivotClessidra.add(vetro, base, tetto,pivotGranelli);
				}
			}



				function Render()
	      {
				     requestAnimationFrame(Render);
						 controls.update();

//ClessidraSx*******************************************************************************************************
						 if(inverso)//verso inverso
						 {
							 if(count<1){
 							for(var i=start;i>=end;i--){
 								if(posIesimaY1[i]<=h/2){
 										p1[i] -= (l*gap)/(h*2*Math.PI);
 								}
 								else{
 										p1[i]+=(l*gap)/(h*2*Math.PI);
 								}
								if(i == start) {
 									tempo1[i] += angolo/(2.0*Math.PI);
 								}else {
 									tempo1[i] = Math.max(0.0, tempo1[i+1]-angolo/(2.0*Math.PI));
 								}

 								//pivot usato per centrare  la spirale inversa
 								pivotAggiustaMovimento1.add(granelli1[i]);
 								pivotAggiustaMovimento1.position.set(0,6-(3*dimSabbia/2),0);

 								//spirale granelli1 inversa
 								granelli1[i].position.set(Math.cos(tempo1[i])*(l/2-p1[i]),posIesimaY1[i],Math.sin(tempo1[i])*(d/2-p1[i]));//-(i*60)
 								posIesimaY1[i] -= gap/(2.0*Math.PI);

 								//quando arrivo all'altezzaMassima devo ordinare i granelli1 nella griglia
 								if(posIesimaY1[i]<=dimSabbia){
 									start -= 1;//il primo granello non serve piu contarlo
 									var x = arrayPosGranelli1[i].x;
 									var y = arrayPosGranelli1[i].y;
 									var z = arrayPosGranelli1[i].z;
 									granelli1[i].position.set(x,y-5,z);//dimSabbia
 									if(start==-1){//abilito drirro
 										inverso=false;
 										start= t-1;
 										end = t-1;
 									}
 								}
 								count +=1;
 						 		}
 							}else{
 								if(end>0){
 								end -=1;}
 								count =0;
 							}
						 }
						 else//verso dritto
						 {
						  if(count<1){
							for(var i=start;i>=end;i--){
								if(posIesimaY1[i]<=h/2){
										p1[i] += (l*gap)/(h*2*Math.PI);
								}
								else{
										p1[i]-=(l*gap)/(h*2*Math.PI);
										}
								if(i == start) {
									tempo1[i] += angolo/(2.0*Math.PI);
								}else {
									tempo1[i] = Math.max(0.0, tempo1[i+1]-angolo/(2.0*Math.PI));
								}

								//pivot usato per centrare  la spirale
								pivotAggiustaMovimento1.add(granelli1[i]);
								pivotAggiustaMovimento1.position.set(0,6-(3*dimSabbia/2),0);

								//spirale granelli1
								granelli1[i].position.set(Math.cos(tempo1[i])*(l/2-p1[i]),posIesimaY1[i],Math.sin(tempo1[i])*(d/2-p1[i]));//-(i*60)
								posIesimaY1[i] += gap/(2.0*Math.PI);

								//quando arrivo all'altezzaMassima devo orginare i granelli1
								if(posIesimaY1[i]>=h-dimSabbia){
									start -= 1;//il primo granello non serve piu contarlo
									var x = arrayPosGranelli1[i].x;
									var y = arrayPosGranelli1[i].y;
									var z = arrayPosGranelli1[i].z;
									granelli1[i].position.set(x,h-(y-5),z);//dimSabbia
									if(start==-1){//abilito l'inverso
										inverso=true;
										start= t-1;
										end = t-1;
									}
								}
								count +=1;
						 		}
							}else{
								if(end>0){
								end -=1;}
								count =0;
							}
						}

//ClessidraDx************************************************************************************************
						 if(!inverso)//verso inverso
						 {
							 if(count<1){
 							for(var i=start;i>=end;i--){
 								if(posIesimaY2[i]<=h/2){
 										p2[i] -= (l*gap)/(h*2*Math.PI);
 								}
 								else{
 										p2[i]+=(l*gap)/(h*2*Math.PI);
 								}
								if(i == start) {
 									tempo2[i] += angolo/(2.0*Math.PI);
 								}else {
 									tempo2[i] = Math.max(0.0, tempo2[i+1]-angolo/(2.0*Math.PI));
 								}

 								//pivot usato per centrare  la spirale inversa
 								pivotAggiustaMovimento2.add(granelli2[i]);
 								pivotAggiustaMovimento2.position.set(0,6-(3*dimSabbia/2),0);

 								//spirale granelli2 inversa
 								granelli2[i].position.set(Math.cos(tempo2[i])*(l/2-p2[i]),posIesimaY2[i],Math.sin(tempo2[i])*(d/2-p2[i]));//-(i*60)
 								posIesimaY2[i] -= gap/(2.0*Math.PI);

 								//quando arrivo all'altezzaMassima devo ordinare i granelli2 nella griglia
 								if(posIesimaY2[i]<=dimSabbia){
 									start -= 1;//il primo granello non serve piu contarlo
 									var x = arrayPosGranelli2[i].x;
 									var y = arrayPosGranelli2[i].y;
 									var z = arrayPosGranelli2[i].z;
 									granelli2[i].position.set(x,y-5,z);//dimSabbia
 									if(start==-1){//abilito drirro
 										inverso=false;
 										start= t-1;
 										end = t-1;
 									}
 								}
 								count +=1;
 						 		}
 							}else{
 								if(end>0){
 								end -=1;}
 								count =0;
 							}
						 }
						 else//verso dritto
						 {
						  if(count<1){
							for(var i=start;i>=end;i--){
								if(posIesimaY2[i]<=h/2){
										p2[i] += (l*gap)/(h*2*Math.PI);
								}
								else{
										p2[i]-=(l*gap)/(h*2*Math.PI);
										}
								if(i == start) {
									tempo2[i] += angolo/(2.0*Math.PI);
								}else {
									tempo2[i] = Math.max(0.0, tempo2[i+1]-angolo/(2.0*Math.PI));
								}

								//pivot usato per centrare  la spirale
								pivotAggiustaMovimento2.add(granelli2[i]);
								pivotAggiustaMovimento2.position.set(0,6-(3*dimSabbia/2),0);

								//spirale granelli2
								granelli2[i].position.set(Math.cos(tempo2[i])*(l/2-p2[i]),posIesimaY2[i],Math.sin(tempo2[i])*(d/2-p2[i]));//-(i*60)
								posIesimaY2[i] += gap/(2.0*Math.PI);

								//quando arrivo all'altezzaMassima devo orginare i granelli2
								if(posIesimaY2[i]>=h-dimSabbia){
									start -= 1;//il primo granello non serve piu contarlo
									var x = arrayPosGranelli2[i].x;
									var y = arrayPosGranelli2[i].y;
									var z = arrayPosGranelli2[i].z;
									granelli2[i].position.set(x,h-(y-5),z);//dimSabbia
									if(start==-1){//abilito l'inverso
										inverso=true;
										start= t-1;
										end = t-1;
									}
								}
								count +=1;
						 		}
							}else{
								if(end>0){
								end -=1;}
								count =0;
							}
						}
						 stats.update();
					   renderer.render(scene, camera);
				}

					function creaBaseClessidra(m){
						pivot = new THREE.Object3D();
						var height = m*1;
						var basamento = m*3;
						l = basamento;
						d = basamento;
						var colorBase = 0xffd700;
						var livBase1 = creaQuadrilatero(basamento,height,basamento,colorBase, "textures/OroClessidra.jpg");
						var livBase2 = creaQuadrilatero(basamento + m*1,height, basamento + m*1,colorBase, "textures/OroClessidra.jpg");
						var livBase3 = creaQuadrilatero(basamento + m*2,height,basamento + m*2,colorBase, "textures/OroClessidra.jpg");
						livBase2.position.set(0,height,0);
						livBase3.position.set(0,2*height,0);
						pivot.add(livBase1,livBase2,livBase3);
						return pivot;
					}

					function creaVetroClessidra(m){

						// Unione pezzi clessidra
						pivotVetroClessidra = new THREE.Object3D();
						var dimensioneLato = 5;
						var posizioneVetro = m*5;
						// parte sotto
						metaClessidra1 = metaVetroClessidra(dimensioneLato, m);
						// parte sopra
						metaClessidra2 = metaVetroClessidra(dimensioneLato, m);
						// Regolazione parti sopra-sotto
						metaClessidra1.position.set(0,posizioneVetro,0);
						metaClessidra2.position.set(0,3*posizioneVetro,0);
						metaClessidra2.rotation.set(180*Math.PI/180,0,0);
						// Parte centrale
						centroClessidra = creaQuadrilateroTrasparente(m*1,m*1,m*1,0x000000);
						centroClessidra.position.set(0,2*posizioneVetro,0);
						pivotVetroClessidra.add(metaClessidra1, metaClessidra2, centroClessidra);
						return pivotVetroClessidra;
					}

					function metaVetroClessidra(l, m){
						pivot = new THREE.Object3D();
						var altezzaVetri = m*1;
						var colorBase = 0x000000;
						var metaVetro = creaQuadrilateroTrasparente(m*l,m*l,m*l,colorBase);
						var metaVetro1 = creaQuadrilateroTrasparente(m*(l-1), altezzaVetri, m*(l-1),colorBase);
						var metaVetro2 = creaQuadrilateroTrasparente(m*(l-2), altezzaVetri, m*(l-2),colorBase);
						metaVetro1.position.set(0,m*2 + altezzaVetri,0);
						metaVetro2.position.set(0,m*2 + 2*altezzaVetri,0);
						pivot.add(metaVetro, metaVetro1, metaVetro2);
						return pivot;
					}

					function creaQuadrilatero(larghezza, altezza, profondita, colore, image){
						// Costruzione plane generico
						var geometryPlane = new THREE.BoxGeometry(larghezza, altezza, profondita);
						//
						if(image == undefined){
						var planeMaterial = new THREE.MeshBasicMaterial( { color: colore } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
					} else {
						var texture = new THREE.TextureLoader().load( image );
						var planeMaterial = new THREE.MeshBasicMaterial( { map: texture } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
					}
						return plane;
					}

					function creaQuadrilateroTrasparente(larghezza, altezza, profondita, colore){
						// Costruzione plane generico
						var geometryPlane = new THREE.BoxGeometry(larghezza, altezza, profondita);
						var planeMaterial = new THREE.MeshBasicMaterial( { color: colore, transparent: true, opacity:0.05 } );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
						var plane = new THREE.Mesh( geometryPlane, planeMaterial );
						return plane;
					}

			Start();
			Render();
		</script>
	</body>
</html>
